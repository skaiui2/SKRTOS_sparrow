# 单核调度算法

由于内核目前只是一个实时操作系统，因此我们的调度算法只讨论实时调度算法，目前也只支持单核，所以也只简单谈一下单核。



## 实时性

许多人学习的都是非实时操作系统的理论知识，因此总是混淆两者的不同，实际上，虽然两者的设计理念都是大同小异，但本质上却存在巨大差别。

实时性指的是可计算，而不是有多快。

非实时操作系统的并发概念并不适用于实时操作系统的线程设计，对于前者，如果有n个任务，它的调度算法会趋向于使每个任务获得1/n的CPU时间，这就是其调度算法设计的一个重要标准：公平性。这个设计的好处就是：能人使用者感觉任务在同时运行。所以，时间片是调度算法的重要设计成分，任务花光它的时间片就会下线。

但是，在实时操作系统中，线程本来就有优先级之分，时间片可有可无，如果一个任务优先级一直最高且处于运行状态，那么它将一直执行。

那么实时操作系统的实时（REAL_TIME）到底是什么呢？

其实是可计算性。

## 周期和计算

实时操作系统的精髓不仅包括多线程的实现，更重要的一点是：它提供的任务延时函数。

每个任务执行完后，都会延时一段时间，再执行一次，如此反复，这就形成了周期性。

换而言之，在编写好程序后，如果程序中的动态执行任务比较少，使用者可以使用计算机模拟每一分每一秒都是哪些线程在执行。

如果使用者设计优秀的数学算法，那么可以通过公式得出实时性的预测，当然，也可以简化任务流程，只关注时间和任务部分。

数学算法暂且不谈，至于简化任务流程，最常见的数据结构就是堆。

### 堆

我们使用堆进行计算，每次取出最早执行的任务，同时更新任务下一次执行时间，由于任务都是周期性的，因此我们的计算变得额外简单，这样，我们就进行了一次简单但高效的预测。

```
struct Task {
    id
    priority
    next_execution_time  // 任务的下一次执行时间
}

heap taskQueue  // 任务队列（最小堆）

function pushTask(task):  // 插入任务
    add task to taskQueue
    heapify_up(taskQueue)

function popTask():  // 取出最早执行的任务
    task = taskQueue.top()
    remove top element from taskQueue
    heapify_down(taskQueue)
    return task

function scheduler():  // 任务调度器
    while true:
        task = popTask()
        execute task
        update task.next_execution_time
        pushTask(task)

```

堆（多优先级队列）是一种非常高效的数据结构，它只关心最优先的那个成员。

内核中线程的执行就像一个招待客人的店铺，如果每一位客人都预约好了时间且没有发生意外的话，那么我们可以通过数据结构-堆很轻松模拟出店铺一天的接待情况。









