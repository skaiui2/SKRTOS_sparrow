# 多核调度算法

多核调度算法针对的是程序并行性，不管操作系统是实时还是非实时，一个令人头疼的问题就是CPU的分配。

笔者的多核调度算法的想法并不是来自于市面上的操作系统成熟的调度算法,而是来自于编译器后端设计的多面体编译技术,如果以后有时间,笔者会尝试实现它.当然,笔者肯定不是第一个这么想的人,应该有操作系统或框架实现了笔者的想法,不过这无所谓,毕竟笔者写代码的初衷就是找乐子.

虽然我们关注线程级别的并行,但是多面体编译中的数学算法却是通用的.

## 程序并行化

### 流水线架构

早期的并行化思想可以从流水线架构中体现出来，通过流水线设计，将串行程序拆分成类似并行执行，当然，这属于硬件层面的并行操作了，但是，这一思想仍然可以应用在上层的操作系统中。

```mermaid
graph LR
Aa(第一级)-->Ab(寄存器)-->Ac(第二级)-->Ad(寄存器)
```



### 并行化TCP/IP协议栈设计

因为笔者最近很忙，协议栈还没写完，而且有很多烦人的事情，协议栈的开发也暂时搁置了(不知道何年何月会重新继续,也可能不写了)，所以内核目前还没有集成网络协议栈。

不过，流水线架构的思想可以应用在网络协议栈中,这在多核条件下是十分有利的.

每一个协议栈,基本遵守TCP/IP分层架构,对于任一层来说,只有上层和下层是可见的,基于此,实际上每一层都是可以使用多个线程/进程运行的.

对于输入的数据报,要层层检查并校验,对于输出的数据报,也要要层层构造.

实际上,每一层都是分离的,它可以完全不用写成一种不断嵌套的code形式,而是在层与层之间建立一个缓冲带,类似于流水线之间的寄存器.

数据报可以被挂载在中间的队列上,每一层只用对自己看得见的输入及输出队列负责.而对输入及输入队列的处理,都可以写成线程/进程,这些将会交由不同的CPU负责.

这样,就完成了一个流水线架构的TCP/IP协议栈.

虽然在单核条件下可能并不具有优势,但是在多核条件下,协议栈将具备优越的并行化性能.



### CPU分配

线程与线程之间,可能存在依赖关系(同步),也可能存在对公共资源的竞争状态,因此,在指令集层面的并行通常使用线性规划计算进行优化,这些数学算法仍然可以应用到线程level的并行中.

多面体可以通过一组线性不等式来定义，这些不等式可以表示为矩阵和向量的形式。基于此,我们可以建立一个多面体模型.

## 线性规划

### 线程映射到多面体空间

在多面体模型中，我们用整数来表示循环迭代空间，类似地，我们可以用整数来表示线程执行的调度空间。例如：

```
T(i, j) = { (i, j) | 0 ≤ i < N, 0 ≤ j < M }
```

这里 `(i, j)` 代表一个线程的编号，我们可以通过线性变换将其映射到 CPU 核上：

```
CPU_k = (a * i + b * j) mod K
```

其中：

- `K` 是 CPU 核的数量
- `a, b` 是调度优化系数（用于均衡负载）

### **任务调度优化**

在多面体模型中，我们可以使用 调度向量 来优化任务执行顺序：

```
S(i, j) = α * i + β * j + γ
```

这里 `S(i, j)` 确定了线程 `(i, j)` 的执行顺序.

例如：

```
for each thread (i, j):
    compute optimal execution time S(i, j)
    map thread to CPU core
    execute thread based on scheduling order
```

这样可以确保调度器自动调整任务执行顺序.

### 线程间依赖

多面体建模的一个核心优势是数据流依赖分析，数据依赖有三种类型：

真依赖：写运算后面接一个读运算

反依赖：读运算后面接一个写运算

输出依赖：两个针对同一个位置的写运算



依赖性产生的条件：

1.必须有一个操作是写操作

2.存在不同的迭代访问了同一个内存位置

我们需要通过几何学并进行数学归纳分析出依赖关系,并将其添加到我们的线性约束条件中,为了寻找依赖问题是否有解,我们必须对我们建立的不等式进行测试,如果有解,那么,我们需要面对的就是最后的数学线性规划问题.

所以到了最终,为了寻找最优化解,我们都必须解决一个数学算法:**AX>=0**,该算法可以使用启发式算法设计.

### **应用**

假设我们有一个矩阵计算任务：

```
A[i, j] = B[i, j] + C[i, j]
```

如果直接使用线程：

```
for each (i, j):
    spawn thread T(i, j)
    execute A[i, j] = B[i, j] + C[i, j]
```

这样可能会导致线程竞争，所以我们还需要分析依赖关系.

最终优化后：

```
for each thread (i, j):
    compute optimal execution order S(i, j)
    map thread to CPU_k
    execute A[i, j] = B[i, j] + C[i, j]
```

