## 抽象代数中的MOD2加法

在抽象代数中，整数在模2的加法运算可以形成一个特定的代数结构。

运算如下：

```
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 0
```

对于该代数结构，可以形成一个群，即满足以下性质：封闭性、结合性、单位元、逆元

对于逆元性质，即：每个元素都是其自身的逆元

除此之外，还满足A^B = B ^A的性质，也就是说，该运算可以构成一个阿贝尔群。

这其实就是异或运算，我们将会使用该运算完成两个数的交互，而不用借助第三个变量。



## 推导

设a = A, b = B有如下函数，这里直接假设都是全局变量：

```
void swap()
{
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
}
```

对于该群，运算即为：

```
a = A ^ B;
b = (A ^ B) ^ B;
a = (A ^ B) ^ A; 
```

在第二步，使用群的结合律、结合律与逆元性质，可得：

```
b = (A ^ B) ^ B = A ^ (B ^ B) = A ^ 0 = A
```

由单位元性质，即b的值此时为A

在第三步：
```
a = A ^ (B ^ A) = (A ^ A) ^ B = B
```

经过该群的运算，我们可以证明a，b的值发生了交换。

当然，这里我们假设a,b是两个单独的变量，因为这是证明。但是在计算机中，如果a,b的地址相同，运算就不能成立了，不过a与b地址相同时，也根本不用交互。

所以说，在进行交换前，建议加一个判断:

```
void swap(int *a, int *b)
{
	if (a != b) {
		*a = *a ^ *b;
		*b = *a ^ *b;
		*a = *a ^ *b;
	}
}
```

