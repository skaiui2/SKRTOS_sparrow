## 链表包含万物还是万物包含链表？

在内核的scheduler文件夹的class.h文件中，有一个宏：

```
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))
```

这段代码来自Linux内核中的container_of宏。

使用该宏的原因非常简单：我们想通过结构体的成员找到结构体。

许多程序都需要使用链表，Linux内核在设计时，不得不考虑一个问题：链表包含万物还是万物包含链表？



### 链表包含万物

SKRTOS的链表设计如下：

```
Class(ListNode)
{
    uint32_t value;
    ListNode* prev;
    ListNode* next;
    void    *TheList;
};
```

**优点**

通过链表结构体之间的遍历，我们可以非常方便找到TheList这些成员。

**缺点**

对于一个基本的链表来说，TheList这些成员是多余的，如果我们使用该链表挂载别的东西，那么这些成员会浪费空间。

## 万物包含链表

我们可以只实现链表最简单的操作，如果需要增加链表功能，在最基本的结构体上添加即可，形成一个包装的结构体。

在遍历时，我们可以通过链表找到更改后的包装结构体，再从结构体中寻找我们需要的成员。

例如，在内核的scheduler.c中有结构体如下：

如果我们想找到下一个任务，我们可以通过任务的task_node找到下一个链表节点，再通过该节点找到下一个任务。

```
Class(TCB_t)
{
    volatile uint32_t *pxTopOfStack;
    ListNode task_node;
    ListNode IPC_node;
    uint8_t state;
    uint8_t uxPriority;
    uint32_t * pxStack;
    uint8_t TimeSlice;
};
```

TCB_t中有成员task_node，如何通过该成员找到TCB_t的起始地址呢？

## 内存

由于结构体中内存中的存放是连续的，因此我们可以在task_node地址的基础上减去uint32_t大小，就可以找到TCB_t的起始地址。



## 困难

手动计算是非常麻烦的，而且，不同编译器对内存字节对齐的处理会根据程序和CPU架构而产生不同的效果，手动计算不一定准确，因此我们需要一个计算偏移的操作，也就是offsetof函数。

因此得到以下宏：

```
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))
```



## 缺陷

设计内核必须考虑程序的性能，使用该宏有一个非常明显的缺陷，那就是减法操作：

```
((type *)((char *)(ptr) - offsetof(type, member)))
```

编译器在处理代码时，可能并不会为我们在编译时就计算偏移，而是放在程序运行时动态计算，可能有读者觉得毫无影响，但是，container_of在内核是会被大量使用的，成百上千次的堆积，会对性能造成影响！



## 一种解决方法

我们可以在链表中添加一个TCB_pointer指针取代container_of宏，该指针会缓存任务节点。

```
Class(ListNode)
{
    uint32_t value;
    ListNode* prev;
    ListNode* next;
    void    *TheList;
    TCB_t   *TCB_pointer;
};
```

### 缺陷

链表可能会被大量结构体使用，难道要在最基本的链表中添加大量用不上的指针吗？

显然，这种用法只适合被少量结构体使用的情况。



## 利用编译器对静态结构体的处理

在大多数情况下，编译器在创建静态结构体时会根据其大小进行字节对齐，因为这些结构体是已知会被用到的。

如果一个结构体的大小是128，那么它会被放在地址是128的倍数的地址上，在前面我们说过：

**结构体中内存中的存放是连续的**

那么该结构体的首地址在128的倍数的地址上，使用位运算：

```
结构体成员地址 &~ 127
```

就可以得到该结构体的地址，其中&~是用来代替除法运算的，这样就可以忽略结构体成员在128的倍数的地址上多余的内存。



### 目前动态创建无法使用

当然，目前内核并不支持动态创建的结构体这样做，因为目前内核的内存管理算法相当粗糙，动态创建的内存默认八字节对齐，不会根据结构体大小作出动态调整。



## 内核设计

目前内核还是根据实际场景混合使用缓存指针和container宏。
