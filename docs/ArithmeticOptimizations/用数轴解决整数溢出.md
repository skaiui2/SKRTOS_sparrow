## 问题

在编写内核的过程中，一个是头疼的问题是整数溢出问题，我们都知道定义的数据类型是有范围的，超过范围就会溢出。

例如uint32_t a，当计数到达2^32时，a的值会变成0。

在内核的schedule.c文件中，我们可以找到一个全局变量：

```
uint32_t  TicksBase = 0;
```

这就是内核的时钟，每过一段时间它就会加1(默认是1ms)，显然，每经过大约50天，这个数就会溢出一次。

如何解决这个问题呢？

诚然，我们可以使用更大的计数单位，但如果计数频率加快，溢出也在所难免。

内核维护两个表解决了这个问题，但是，本文并不是讲这种方法，而是讲另一种方法，这种方法在Linux内核和FreeBSD内核中都被使用过，不过笔者认为一些书上的讲解不清楚，于是写下自己的理解。



## 问题转化

我们可以将整数的范围看成一个数轴，范围是：0到2^32 - 1，如下：

```

范围：0 到 2^32 - 1
2^31在数轴一半的位置

|---------------------------------|--------------------------------------------|
0                               2^31                                     2^32 - 1

```

每个数从0出发，一直往前增长会回到0。

## 定义先后顺序

假设有两个整数a,b，假设情况如下：

**如果a向前走能遇见b，那么我们称a小于b。**

**如果a后退能遇见b，那么我们称a大于b。**

**如果a-1，那么我们称a后退了1，反之，如果a+1，那么我们称a前进了1。**

在整数b溢出的情况中，虽然b的值比a小，但我们知道b其实是比a更早出发的。



## 假设两个数之差小于数轴的一半

假设两个数之差小于数轴的一半，为什么要这样假设呢？其实这就是变量的运动范围。

令a = 2^31 + 2,b = 0。

在数轴上表示如下：

```

范围：0 到 2^32 - 1

|---------------------------------|------------------------------------|
0                               2^31 + 2                          2^32 - 1
b的位置                            a的位置                                
```

**我们会发现，如果两个数之差小于数轴的一半，a只有向前走，才能遇到b，如果往后退，那么它范围有限，不能遇见b。**

**也就是说，b是大于a的，因为b必然是a增长的结果！**



## 用程序表示

那么我们怎样把这个几何方法转化为程序呢？

在FreeBSD中有程序如下：

```
return (int)(a - b) < 0 ;
```

其中a和b都是无符号整数，范围都是：0 到 2^32 - 1。

返回值是true，说明b在a的前面，返回false时相反。

我们都知道：

**当转化为有符号整数时，最高位会被作为符号位。**

### a的值 > b的值时：

**如果没有发生溢出**：

a - b，得到的是两个数在数轴前端的差值，那么这个差值必然小于2^31，类型转化后的差值是**正数**，返回false，说明a在b的前面。

**正数代表：a遇见b，需要后退的差值小于数轴的一半，这是成立的。**

```
此时计算的差值是b到a的距离：

|---------------------------------|------------------------------------|
0         2^30                   2^31 + 2                          2^32 - 1
         b的位置                   a的位置                             c
```



**如果发生了溢出**：

a - b，得到的是两个数在数轴上的差值，差值大于2^31，那么被类型转化后，这个差值是负数，返回值是true，说明b在a的前面。

在数轴上分析，其实就是因为两个数之差小于数轴的一半，但是差值却不对，所以肯定是b发生了溢出。

**负数代表：a遇见b，后退的差值大于数轴的一半，显然，这是不正确的，那么a的只有前进才能遇见b。**

```
此时计算的差值是b到a的距离：


|---------------------------------|------------------------------------|
0                              2^31 + 2                            2^32 - 1
b的位置                          a的位置                                c
```



### a的值 < b的值时：

已知硬件运算的性质：无符号整数的减法在硬件层面处理负值时，会得到两者之间绕回的差值。

简单来说，就是：

令a = 10，b = 20.

a−b= 10 - 20 =10−20+256=246。

**如果没有发生溢出：**

a - b，得到的是两个数在数轴上绕回的的差值的，简单来说，就是( 0到2^30 ) + ( b到c )。

差值大于2^31，那么被类型转化后，这个差值是负数，返回值是true，说明b在a的前面。

**负数代表：a遇见b，后退的差值大于数轴的一半，显然这是不成立的，那么a只有前进才能遇见b。**

```
此时计算的差值是b到a的距离：


|-----------|----------------------|------------------------------------|
0          2^30                 2^31 + 2                            2^32 - 1
         a的位置                  b的位置                                c
```

**如果发生溢出：**

a - b，得到的也是两个数在数轴上绕回的的差值的。

差值小于2^31，那么被类型转化后，这个差值是正数，返回值是false，说明a在b的前面。

**正数代表：a遇见b，后退的差值小于数轴的一半，显然这是成立的，那么a在b的前面。**

```
此时计算的差值是b到a的距离：


|---------------------------------|------------------------------------|
0                             2^31 + 2                            2^32 - 1
a的位置                         b的位置                                c
```



